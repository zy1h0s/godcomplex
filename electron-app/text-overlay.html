<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Bluetooth Device Manager</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      cursor: default !important;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: transparent;
    }

    #titlebar {
      width: 100%;
      height: 28px;
      background: rgba(0, 0, 0, 0.95);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
      -webkit-app-region: drag;
    }

    .title {
      color: rgba(255, 255, 255, 0.9);
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 1.5px;
      text-transform: uppercase;
    }

    #controls {
      display: flex;
      gap: 4px;
      -webkit-app-region: no-drag;
    }

    .control-btn {
      width: 20px;
      height: 20px;
      border: none;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      transition: all 0.2s;
      font-weight: bold;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .control-btn.active {
      background: rgba(255, 255, 255, 0.3);
    }

    #container {
      width: 100%;
      height: calc(100% - 28px);
      padding: 20px;
      position: relative;
      overflow: hidden;
    }

    body.minimized #container {
      display: none;
    }

    body.minimized #titlebar {
      height: 100%;
      border-bottom: none;
    }

    #textContent {
      width: 100%;
      height: 100%;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-y: auto;
      outline: none;
      -webkit-app-region: no-drag;
      position: relative;
    }

    /* Collaborative cursor indicator */
    .remote-cursor {
      position: absolute;
      width: 2px;
      height: 1.2em;
      background-color: #4285f4;
      pointer-events: none;
      z-index: 10;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .remote-cursor-label {
      position: absolute;
      top: -20px;
      left: 0;
      background-color: #4285f4;
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      white-space: nowrap;
      pointer-events: none;
    }

    /* Text selection highlight */
    .remote-selection {
      position: absolute;
      background-color: rgba(66, 133, 244, 0.3);
      pointer-events: none;
      z-index: 5;
    }

    .click-through-indicator {
      position: absolute;
      bottom: 5px;
      right: 5px;
      padding: 4px 8px;
      background: rgba(102, 126, 234, 0.8);
      color: white;
      border-radius: 4px;
      font-size: 11px;
      display: none;
      -webkit-app-region: no-drag;
    }

    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Light mode - white background, black text */
    body.light-mode #textContent {
      color: #000000 !important;
    }

    body.light-mode .empty {
      color: rgba(0, 0, 0, 0.5);
    }
  </style>
</head>
<body>
  <div id="titlebar">
    <span class="title">TEXT</span>
    <div id="controls">
      <button class="control-btn" onclick="toggleTheme()" id="themeBtn">â˜€</button>
      <button class="control-btn" onclick="openSettings()">âš™</button>
      <button class="control-btn" onclick="toggleMinimize()" id="minimizeBtn">âˆ’</button>
      <button class="control-btn" onclick="closeWindow()">Ã—</button>
    </div>
  </div>
  <div id="container">
    <div id="textContent" contenteditable="true"></div>
    <div class="click-through-indicator" id="clickThroughIndicator">Click-through: ON</div>
  </div>

  <script src="config.js"></script>
  <script>
    const { ipcRenderer } = require('electron');
    const io = require('socket.io-client');

    let socket = null;
    let session = null;
    let settings = null;
    let isUpdatingFromSocket = false;
    let isLightMode = false; // Default to dark mode

    const themeBtn = document.getElementById('themeBtn');

    // Track timeouts for auto-cleanup (for handling disconnects)
    const cursorTimeouts = new Map();
    const selectionTimeouts = new Map();

    const WS_URL = process.env.WS_URL || 'https://godcomplex.onrender.com';

    // Initialize
    ipcRenderer.on('init-overlay', (event, data) => {
      session = data.session;
      settings = data.settings;

      applySettings(settings);
      connectSocket();
    });

    // Apply visual settings
    function applySettings(settings) {
      const container = document.getElementById('container');
      const textContent = document.getElementById('textContent');

      // Background - black/white based on current theme, opacity from settings
      const bgColor = isLightMode ? '#ffffff' : '#000000';
      container.style.background = hexToRgba(bgColor, settings.bgOpacity || 0.3);

      // Text - white for dark mode, black for light mode (CSS handles this)
      textContent.style.fontSize = (settings.fontSize || 16) + 'px';
      textContent.style.fontFamily = settings.fontFamily || 'Arial';
    }

    // Connect to WebSocket
    function connectSocket() {
      socket = io(WS_URL);

      socket.on('connect', () => {
        console.log('Connected to server');
        socket.emit('join-session', {
          sessionId: session.id,
          userId: 'viewer',
          username: 'Viewer'
        });
      });

      socket.on('session-data', ({ text }) => {
        isUpdatingFromSocket = true;
        document.getElementById('textContent').textContent = text || '';
        isUpdatingFromSocket = false;
      });

      socket.on('text-update', ({ text }) => {
        isUpdatingFromSocket = true;
        document.getElementById('textContent').textContent = text || '';
        isUpdatingFromSocket = false;
      });

      // Listen for cursor position updates
      socket.on('cursor-position', ({ cursorStart, cursorEnd, userId, username }) => {
        showRemoteCursor(cursorStart, cursorEnd, userId, username);
      });

      // Listen for text selection updates
      socket.on('text-selection', ({ selectionStart, selectionEnd, userId, username }) => {
        showRemoteSelection(selectionStart, selectionEnd, userId, username);
      });

      socket.on('disconnect', () => {
        console.log('Disconnected from server');
      });
    }

    // Handle text editing (two-way sync)
    let typingTimeout = null;
    document.getElementById('textContent').addEventListener('input', (e) => {
      if (isUpdatingFromSocket) return;

      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        const text = e.target.textContent;
        if (socket && session) {
          socket.emit('text-update', {
            sessionId: session.id,
            text: text,
            userId: 'viewer'
          });
        }
      }, 300);
    });

    // Settings update
    ipcRenderer.on('settings-updated', (event, newSettings) => {
      settings = { ...settings, ...newSettings };
      applySettings(settings);
    });

    // Click-through indicator
    ipcRenderer.on('click-through-changed', (event, isClickThrough) => {
      const indicator = document.getElementById('clickThroughIndicator');
      if (isClickThrough) {
        indicator.style.display = 'block';
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 2000);
      }
    });

    // Show remote cursor position
    function showRemoteCursor(cursorStart, cursorEnd, userId, username) {
      // Clear old timeout for this user
      if (cursorTimeouts.has(userId)) {
        clearTimeout(cursorTimeouts.get(userId));
      }

      // Remove old cursor for this user
      const oldCursor = document.getElementById(`cursor-${userId}`);
      if (oldCursor) oldCursor.remove();

      // Remove any selection for this user (since cursor moved)
      const oldSelection = document.getElementById(`selection-${userId}`);
      if (oldSelection) oldSelection.remove();

      // Also clear selection timeout since we're showing cursor now
      if (selectionTimeouts.has(userId)) {
        clearTimeout(selectionTimeouts.get(userId));
        selectionTimeouts.delete(userId);
      }

      const textContent = document.getElementById('textContent');
      const text = textContent.textContent;

      // Calculate pixel position from character index
      const range = document.createRange();
      const textNode = textContent.firstChild || textContent;

      try {
        if (textNode.nodeType === Node.TEXT_NODE) {
          const pos = Math.min(cursorStart, text.length);
          range.setStart(textNode, pos);
          range.setEnd(textNode, pos);
        } else {
          range.selectNodeContents(textContent);
          range.collapse(true);
        }

        const rect = range.getBoundingClientRect();
        const containerRect = textContent.getBoundingClientRect();

        // Create cursor element
        const cursor = document.createElement('div');
        cursor.id = `cursor-${userId}`;
        cursor.className = 'remote-cursor';
        cursor.style.left = (rect.left - containerRect.left + textContent.scrollLeft) + 'px';
        cursor.style.top = (rect.top - containerRect.top + textContent.scrollTop) + 'px';

        // Create label
        const label = document.createElement('div');
        label.className = 'remote-cursor-label';
        label.textContent = username;
        cursor.appendChild(label);

        textContent.appendChild(cursor);

        // Auto-remove cursor after 10 seconds of inactivity (handles disconnect case)
        const timeout = setTimeout(() => {
          const c = document.getElementById(`cursor-${userId}`);
          if (c) c.remove();
          cursorTimeouts.delete(userId);
        }, 10000);

        cursorTimeouts.set(userId, timeout);
      } catch (e) {
        console.error('Error showing cursor:', e);
      }
    }

    // Show remote text selection
    function showRemoteSelection(selectionStart, selectionEnd, userId, username) {
      // Clear old timeout for this user
      if (selectionTimeouts.has(userId)) {
        clearTimeout(selectionTimeouts.get(userId));
      }

      // Remove old selection for this user
      const oldSelection = document.getElementById(`selection-${userId}`);
      if (oldSelection) oldSelection.remove();

      // Remove cursor for this user (selection replaces it)
      const oldCursor = document.getElementById(`cursor-${userId}`);
      if (oldCursor) oldCursor.remove();

      // Also clear cursor timeout since we're showing selection now
      if (cursorTimeouts.has(userId)) {
        clearTimeout(cursorTimeouts.get(userId));
        cursorTimeouts.delete(userId);
      }

      const textContent = document.getElementById('textContent');
      const text = textContent.textContent;

      const start = Math.min(selectionStart, text.length);
      const end = Math.min(selectionEnd, text.length);

      if (start === end) return; // No selection

      try {
        const range = document.createRange();
        const textNode = textContent.firstChild || textContent;

        if (textNode.nodeType === Node.TEXT_NODE) {
          range.setStart(textNode, start);
          range.setEnd(textNode, end);
        } else {
          return;
        }

        const rects = range.getClientRects();
        const containerRect = textContent.getBoundingClientRect();

        // Create highlight overlays for each line of selection
        const selectionContainer = document.createElement('div');
        selectionContainer.id = `selection-${userId}`;

        for (let i = 0; i < rects.length; i++) {
          const rect = rects[i];
          const highlight = document.createElement('div');
          highlight.className = 'remote-selection';
          highlight.style.left = (rect.left - containerRect.left + textContent.scrollLeft) + 'px';
          highlight.style.top = (rect.top - containerRect.top + textContent.scrollTop) + 'px';
          highlight.style.width = rect.width + 'px';
          highlight.style.height = rect.height + 'px';
          selectionContainer.appendChild(highlight);
        }

        textContent.appendChild(selectionContainer);

        // Auto-remove selection after 10 seconds of inactivity (handles disconnect case)
        const timeout = setTimeout(() => {
          const s = document.getElementById(`selection-${userId}`);
          if (s) s.remove();
          selectionTimeouts.delete(userId);
        }, 10000);

        selectionTimeouts.set(userId, timeout);
      } catch (e) {
        console.error('Error showing selection:', e);
      }
    }

    // Helper function
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function openSettings() {
      ipcRenderer.send('open-settings', 'text');
    }

    function toggleMinimize() {
      ipcRenderer.send('toggle-minimize', 'text');
    }

    function closeWindow() {
      window.close();
    }

    // Toggle between dark and light mode
    function toggleTheme() {
      isLightMode = !isLightMode;
      const container = document.getElementById('container');
      const textContent = document.getElementById('textContent');
      const opacity = settings?.bgOpacity || 0.3;

      if (isLightMode) {
        document.body.classList.add('light-mode');
        themeBtn.textContent = 'ðŸŒ™'; // Moon icon for light mode
        themeBtn.classList.add('active');
        // Apply white background with settings opacity
        container.style.background = hexToRgba('#ffffff', opacity);
      } else {
        document.body.classList.remove('light-mode');
        themeBtn.textContent = 'â˜€'; // Sun icon for dark mode
        themeBtn.classList.remove('active');
        // Apply black background with settings opacity
        container.style.background = hexToRgba('#000000', opacity);
      }

      console.log('Theme toggled:', isLightMode ? 'Light' : 'Dark');
    }

    // Handle minimize state
    ipcRenderer.on('minimized-state', (event, isMinimized) => {
      if (isMinimized) {
        document.body.classList.add('minimized');
        document.getElementById('minimizeBtn').textContent = 'â–¡';
      } else {
        document.body.classList.remove('minimized');
        document.getElementById('minimizeBtn').textContent = 'âˆ’';
      }
    });
  </script>
</body>
</html>
